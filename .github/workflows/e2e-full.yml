name: E2E Full Test

on:
  schedule:
    # Run weekly on Sunday at 2 AM UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      preset:
        description: 'Preset to test (minimal, standard, enterprise, all)'
        required: false
        default: 'standard'
        type: choice
        options:
          - all
          - minimal
          - standard
          - enterprise
      debug:
        description: 'Enable debug logging'
        required: false
        default: false
        type: boolean

concurrency:
  group: e2e-full-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION: '1.23'
  KIND_VERSION: 'v0.24.0'
  ARGOCD_VERSION: '2.13.2'
  KUSTOMIZE_VERSION: '5.5.0'
  HELM_VERSION: '3.16.3'
  TEST_BRANCH_PREFIX: 'test/e2e'

permissions:
  contents: write
  issues: write
  actions: read

jobs:
  # ===========================================================================
  # Build and Generate: Build binary and generate manifests
  # ===========================================================================
  build-and-generate:
    name: Build and Generate Manifests
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.info.outputs.version }}
      commit: ${{ steps.info.outputs.commit }}
      branch_name: ${{ steps.info.outputs.branch_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Generate build info
        id: info
        run: |
          VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "dev")
          COMMIT=$(git rev-parse --short HEAD)
          # Avoid duplicate if version equals commit
          if [ "${VERSION}" = "${COMMIT}" ]; then
            BRANCH_NAME="${TEST_BRANCH_PREFIX}-${COMMIT}-$(date +%s)"
          else
            BRANCH_NAME="${TEST_BRANCH_PREFIX}-${VERSION}-${COMMIT}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "commit=${COMMIT}" >> $GITHUB_OUTPUT
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "::notice::Test branch will be: ${BRANCH_NAME}"

      - name: Set up Go ${{ env.GO_VERSION }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Build gitopsi binary
        run: |
          LDFLAGS="-s -w -X github.com/ihsanmokhlisse/gitopsi/internal/cli.Version=${{ steps.info.outputs.version }} -X github.com/ihsanmokhlisse/gitopsi/internal/cli.Commit=${{ steps.info.outputs.commit }} -X github.com/ihsanmokhlisse/gitopsi/internal/cli.BuildDate=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          CGO_ENABLED=0 go build -ldflags "${LDFLAGS}" -o bin/gitopsi ./cmd/gitopsi

      - name: Verify binary
        run: |
          ./bin/gitopsi version
          ./bin/gitopsi --help

      - name: Install kustomize
        run: |
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash -s -- ${{ env.KUSTOMIZE_VERSION }}
          sudo mv kustomize /usr/local/bin/

      - name: Generate manifests (standard preset)
        run: |
          mkdir -p output
          ./bin/gitopsi init \
            --config test/e2e/fixtures/standard-config.yaml \
            --output output \
            --verbose

      - name: Validate YAML syntax
        run: |
          find output -name "*.yaml" -o -name "*.yml" | while read f; do
            echo "Validating: $f"
            yq eval '.' "$f" > /dev/null || exit 1
          done

      - name: Validate with kustomize build
        run: |
          for dir in output/*/infrastructure/overlays/*/; do
            if [ -f "${dir}kustomization.yaml" ]; then
              echo "Building: $dir"
              kustomize build "$dir" > /dev/null || exit 1
            fi
          done

      - name: Run gitopsi validate
        run: ./bin/gitopsi validate output/test-standard

      - name: Upload binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: gitopsi-binary
          path: bin/gitopsi
          retention-days: 1

      - name: Upload manifests artifact
        uses: actions/upload-artifact@v4
        with:
          name: manifests
          path: output/
          retention-days: 1

  # ===========================================================================
  # CLI Testing: Test CLI commands (no cluster needed)
  # ===========================================================================
  cli-test:
    name: CLI Command Testing
    needs: [build-and-generate]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Download binary
        uses: actions/download-artifact@v4
        with:
          name: gitopsi-binary
          path: bin

      - name: Make binary executable
        run: chmod +x bin/gitopsi

      - name: Test version command
        run: ./bin/gitopsi version

      - name: Test help commands
        run: |
          ./bin/gitopsi --help
          ./bin/gitopsi init --help
          ./bin/gitopsi validate --help
          ./bin/gitopsi preflight --help
          ./bin/gitopsi env --help

      - name: Test validate command
        run: |
          mkdir -p test-output
          ./bin/gitopsi init \
            --config test/e2e/fixtures/minimal-config.yaml \
            --output test-output \
            --verbose
          ./bin/gitopsi validate test-output/test-minimal

  # ===========================================================================
  # E2E Cluster Test: All cluster operations in one job
  # ===========================================================================
  e2e-cluster:
    name: E2E Cluster Test
    needs: [build-and-generate]
    runs-on: ubuntu-latest
    env:
      BRANCH_NAME: ${{ needs.build-and-generate.outputs.branch_name }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download binary
        uses: actions/download-artifact@v4
        with:
          name: gitopsi-binary
          path: bin

      - name: Download manifests
        uses: actions/download-artifact@v4
        with:
          name: manifests
          path: manifests

      - name: Make binary executable
        run: chmod +x bin/gitopsi

      # --- Git Push Phase ---
      - name: Create and push test branch
        id: git-push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create orphan branch with manifests
          git checkout --orphan "${BRANCH_NAME}"
          git rm -rf . || true

          # Copy generated manifests
          cp -r manifests/test-standard/* .

          # Commit and push
          git add -A
          git commit -m "E2E test manifests for ${{ needs.build-and-generate.outputs.version }}"
          git push origin "${BRANCH_NAME}"

          echo "pushed=true" >> $GITHUB_OUTPUT
          echo "::notice::Pushed manifests to branch: ${BRANCH_NAME}"

      # --- Kind Cluster Phase ---
      - name: Install kind
        run: |
          curl -Lo /tmp/kind https://kind.sigs.k8s.io/dl/${{ env.KIND_VERSION }}/kind-linux-amd64
          chmod +x /tmp/kind
          sudo mv /tmp/kind /usr/local/bin/kind
          kind version

      - name: Create kind cluster
        run: |
          cat <<EOF | kind create cluster --name e2e-test --config=-
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
            - role: control-plane
          EOF
        timeout-minutes: 3

      - name: Verify cluster
        run: |
          kubectl cluster-info
          kubectl get nodes
          kubectl wait --for=condition=Ready nodes --all --timeout=120s

      # --- ArgoCD Bootstrap Phase ---
      - name: Install Helm
        run: |
          curl -fsSL https://get.helm.sh/helm-v${{ env.HELM_VERSION }}-linux-amd64.tar.gz | tar xz
          sudo mv linux-amd64/helm /usr/local/bin/
          helm version

      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o /tmp/argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v${{ env.ARGOCD_VERSION }}/argocd-linux-amd64
          chmod +x /tmp/argocd-linux-amd64
          sudo mv /tmp/argocd-linux-amd64 /usr/local/bin/argocd
          argocd version --client

      - name: Install ArgoCD via Helm
        run: |
          helm repo add argo https://argoproj.github.io/argo-helm
          helm repo update
          kubectl create namespace argocd
          helm install argocd argo/argo-cd \
            --namespace argocd \
            --set configs.params."server\.insecure"=true \
            --wait \
            --timeout 5m
        timeout-minutes: 6

      - name: Wait for ArgoCD to be ready
        run: |
          kubectl -n argocd wait --for=condition=available deployment/argocd-server --timeout=180s
          kubectl -n argocd wait --for=condition=available deployment/argocd-repo-server --timeout=180s
          kubectl -n argocd get pods

      - name: Get ArgoCD admin password
        id: argocd-password
        run: |
          PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::${PASSWORD}"
          echo "password=${PASSWORD}" >> $GITHUB_OUTPUT

      # --- Sync Verification Phase ---
      - name: Port-forward ArgoCD
        run: |
          kubectl -n argocd port-forward svc/argocd-server 8080:80 &
          sleep 5

      - name: Login to ArgoCD
        run: |
          argocd login localhost:8080 \
            --username admin \
            --password "${{ steps.argocd-password.outputs.password }}" \
            --insecure \
            --plaintext

      - name: Create ArgoCD Application
        run: |
          argocd app create e2e-test-app \
            --repo https://github.com/${{ github.repository }}.git \
            --revision "${BRANCH_NAME}" \
            --path "infrastructure/overlays/dev" \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace dev \
            --sync-policy automated \
            --auto-prune \
            --self-heal

      - name: Sync and wait
        run: |
          argocd app sync e2e-test-app --timeout 300 || true
          argocd app wait e2e-test-app --sync --timeout 300 || echo "Sync may have issues"
        timeout-minutes: 6

      - name: Verify sync status
        run: |
          argocd app get e2e-test-app
          STATUS=$(argocd app get e2e-test-app -o json | jq -r '.status.sync.status')
          echo "Sync Status: ${STATUS}"

          # Check namespaces created
          echo "=== Namespaces ==="
          kubectl get namespaces

      # --- Cleanup Phase (always runs) ---
      - name: Delete kind cluster
        if: always()
        run: kind delete cluster --name e2e-test || true

      - name: Delete test branch
        if: always()
        run: |
          git push origin --delete "${BRANCH_NAME}" || echo "Branch may not exist"
        env:
          GITHUB_TOKEN: ${{ github.token }}

  # ===========================================================================
  # Report Failure
  # ===========================================================================
  report-failure:
    name: Report Failure
    needs: [build-and-generate, cli-test, e2e-cluster]
    runs-on: ubuntu-latest
    if: failure()
    steps:
      - name: Check for existing issue
        id: check
        run: |
          EXISTING=$(gh issue list --repo ${{ github.repository }} --search "E2E Test Failure" --state open --json number --jq 'length')
          if [ "${EXISTING}" -gt "0" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Create failure issue
        if: steps.check.outputs.exists == 'false'
        env:
          GH_TOKEN: ${{ github.token }}
          VERSION: ${{ needs.build-and-generate.outputs.version }}
          COMMIT: ${{ needs.build-and-generate.outputs.commit }}
          BRANCH_NAME: ${{ needs.build-and-generate.outputs.branch_name }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          cat <<EOF > /tmp/issue_body.md
          ## E2E Test Failure

          **Workflow Run**: ${RUN_URL}

          **Version**: ${VERSION}
          **Commit**: ${COMMIT}
          **Branch**: ${{ github.ref_name }}
          **Triggered**: ${{ github.event_name }}

          ### Debug Information
          - Test branch: \`${BRANCH_NAME}\`
          - Go version: \`${{ env.GO_VERSION }}\`
          - Kind version: \`${{ env.KIND_VERSION }}\`
          - ArgoCD version: \`${{ env.ARGOCD_VERSION }}\`

          ### Next Steps
          1. Check the failed job logs
          2. Reproduce locally if possible
          3. Fix the issue and re-run the workflow
          EOF

          gh issue create \
            --repo ${{ github.repository }} \
            --title "E2E Test Failure: ${VERSION}-${COMMIT}" \
            --body-file /tmp/issue_body.md
